{"version":3,"file":"bundle.umd.js","sources":["../node_modules/tslib/tslib.es6.js","../src/storeUtils.ts","../src/directives.ts","../src/fragments.ts","../src/util/assign.ts","../src/getFromAST.ts","../src/util/filterInPlace.ts","../src/transform.ts","../src/util/cloneDeep.ts","../src/util/environment.ts","../src/util/errorHandling.ts","../src/util/isEqual.ts","../src/util/maybeDeepFreeze.ts","../src/util/warnOnce.ts","../src/util/stripSymbols.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new Error(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject &&\n    (idObject as IdValue | JsonValue).type === 'id' &&\n    typeof (idObject as IdValue).generated === 'boolean';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new Error(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle\n// the `skip` and `include` directives within GraphQL.\nimport {\n  FieldNode,\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n} from 'graphql';\n\nimport { visit } from 'graphql/language/visitor';\n\nimport { argumentsObjectFromField } from './storeUtils';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function getDirectiveInfoFromField(\n  field: FieldNode,\n  variables: Object,\n): DirectiveInfo {\n  if (field.directives && field.directives.length) {\n    const directiveObj: DirectiveInfo = {};\n    field.directives.forEach((directive: DirectiveNode) => {\n      directiveObj[directive.name.value] = argumentsObjectFromField(\n        directive,\n        variables,\n      );\n    });\n    return directiveObj;\n  }\n  return null;\n}\n\nexport function shouldInclude(\n  selection: SelectionNode,\n  variables: { [name: string]: any } = {},\n): boolean {\n  if (!selection.directives) {\n    return true;\n  }\n\n  let res: boolean = true;\n  selection.directives.forEach(directive => {\n    // TODO should move this validation to GraphQL validation once that's implemented.\n    if (directive.name.value !== 'skip' && directive.name.value !== 'include') {\n      // Just don't worry about directives we don't understand\n      return;\n    }\n\n    //evaluate the \"if\" argument and skip (i.e. return undefined) if it evaluates to true.\n    const directiveArguments = directive.arguments || [];\n    const directiveName = directive.name.value;\n    if (directiveArguments.length !== 1) {\n      throw new Error(\n        `Incorrect number of arguments for the @${directiveName} directive.`,\n      );\n    }\n\n    const ifArgument = directiveArguments[0];\n    if (!ifArgument.name || ifArgument.name.value !== 'if') {\n      throw new Error(`Invalid argument for the @${directiveName} directive.`);\n    }\n\n    const ifValue = directiveArguments[0].value;\n    let evaledValue: boolean = false;\n    if (!ifValue || ifValue.kind !== 'BooleanValue') {\n      // means it has to be a variable value if this is a valid @skip or @include directive\n      if (ifValue.kind !== 'Variable') {\n        throw new Error(\n          `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n        );\n      } else {\n        evaledValue = variables[(ifValue as VariableNode).name.value];\n        if (evaledValue === undefined) {\n          throw new Error(\n            `Invalid variable referenced in @${directiveName} directive.`,\n          );\n        }\n      }\n    } else {\n      evaledValue = (ifValue as BooleanValueNode).value;\n    }\n\n    if (directiveName === 'skip') {\n      evaledValue = !evaledValue;\n    }\n\n    if (!evaledValue) {\n      res = false;\n    }\n  });\n\n  return res;\n}\n\nexport function getDirectiveNames(doc: DocumentNode) {\n  const names: string[] = [];\n\n  visit(doc, {\n    Directive(node) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], doc: DocumentNode) {\n  return getDirectiveNames(doc).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more then one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new Error(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    if (fragments.length !== 1) {\n      throw new Error(\n        `Found ${\n          fragments.length\n        } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      );\n    }\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: [\n            {\n              kind: 'FragmentSpread',\n              name: {\n                kind: 'Name',\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n","/**\n * Adds the properties of one or more source objects to a target object. Works exactly like\n * `Object.assign`, but as a utility to maintain support for IE 11.\n *\n * @see https://github.com/apollostack/apollo-client/pull/1009\n */\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n): A & B & C & D & E;\nexport function assign(target: any, ...sources: Array<any>): any;\nexport function assign(\n  target: { [key: string]: any },\n  ...sources: Array<{ [key: string]: any }>\n): { [key: string]: any } {\n  sources.forEach(source => {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n    Object.keys(source).forEach(key => {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  if (!mutationDef) {\n    throw new Error('Must contain a mutation definition.');\n  }\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new Error(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  if (operations.length > 1) {\n    throw new Error(\n      `Ambiguous GraphQL document: contains ${operations.length} operations`,\n    );\n  }\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  if (!def) {\n    throw new Error(`GraphQL document is missing an operation`);\n  }\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  if (!queryDef || queryDef.operation !== 'query') {\n    throw new Error('Must contain a query definition.');\n  }\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  if (doc.definitions.length > 1) {\n    throw new Error('Fragment must have exactly one definition.');\n  }\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  if (fragmentDef.kind !== 'FragmentDefinition') {\n    throw new Error('Must be a fragment definition.');\n  }\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new Error(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from 'graphql';\nimport { visit } from 'graphql/language/visitor';\n\nimport {\n  checkDocument,\n  getOperationDefinitionOrDie,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n} from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinitionOrDie(doc),\n    createFragmentMap(\n      getFragmentDefinitions(doc)\n    ),\n  ) ? null : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(visit(doc, {\n    Variable: {\n      enter(node, _key, parent) {\n        // Store each variable that's referenced as part of an argument\n        // (excluding operation definition variables), so we know which\n        // variables are being used. If we later want to remove a variable\n        // we'll fist check to see if it's being used, before continuing with\n        // the removal.\n        if ((parent as VariableDefinitionNode).kind !== 'VariableDefinition') {\n          variablesInUse[node.name.value] = true;\n        }\n      },\n    },\n\n    Field: {\n      enter(node) {\n        // If `remove` is set to true for a directive, and a directive match\n        // is found for a field, remove the field as well.\n        const shouldRemoveField = directives.some(\n          directive => directive.remove,\n        );\n\n        if (\n          shouldRemoveField &&\n          node.directives &&\n          node.directives.some(getDirectiveMatcher(directives))\n        ) {\n          if (node.arguments) {\n            // Store field argument variables so they can be removed\n            // from the operation definition.\n            node.arguments.forEach(arg => {\n              if (arg.value.kind === 'Variable') {\n                variablesToRemove.push({\n                  name: (arg.value as VariableNode).name.value,\n                });\n              }\n            });\n          }\n\n          if (node.selectionSet) {\n            // Store fragment spread names so they can be removed from the\n            // docuemnt.\n            getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n              frag => {\n                fragmentSpreadsToRemove.push({\n                  name: frag.name.value,\n                });\n              },\n            );\n          }\n\n          // Remove the field.\n          return null;\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node) {\n        // Keep track of referenced fragment spreads. This is used to\n        // determine if top level fragment definitions should be removed.\n        fragmentSpreadsInUse[node.name.value] = true;\n      },\n    },\n\n    Directive: {\n      enter(node) {\n        // If a matching directive is found, remove it.\n        if (getDirectiveMatcher(directives)(node)) {\n          return null;\n        }\n      },\n    },\n  }));\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (modifiedDoc &&\n      filterInPlace(variablesToRemove, v => !variablesInUse[v.name]).length) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (modifiedDoc &&\n      filterInPlace(\n        fragmentSpreadsToRemove,\n        fs => !fragmentSpreadsInUse[fs.name],\n      ).length) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            selection.kind === 'Field' &&\n            ((selection as FieldNode).name.value === '__typename' ||\n              (selection as FieldNode).name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        console.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  return (\n    selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (selection.kind !== 'Field' || !(selection as FieldNode)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  checkDocument(doc);\n\n  let parentPath: string;\n\n  return nullIfDocIsEmpty(visit(doc, {\n    SelectionSet: {\n      enter(node, _key, _parent, path) {\n        const currentPath = path.join('-');\n\n        if (\n          !parentPath ||\n          currentPath === parentPath ||\n          !currentPath.startsWith(parentPath)\n        ) {\n          if (node.selections) {\n            const selectionsWithDirectives = node.selections.filter(selection =>\n              hasDirectivesInSelection(directives, selection),\n            );\n\n            if (hasDirectivesInSelectionSet(directives, node, false)) {\n              parentPath = currentPath;\n            }\n\n            return {\n              ...node,\n              selections: selectionsWithDirectives,\n            };\n          } else {\n            return null;\n          }\n        }\n      },\n    },\n  }));\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          // Remove matching top level variables definitions.\n          variableDefinitions: node.variableDefinitions.filter(\n            varDef => !config.some(arg => arg.name === varDef.variable.name.value),\n          ),\n        };\n      },\n    },\n\n    Field: {\n      enter(node) {\n        // If `remove` is set to true for an argument, and an argument match\n        // is found for a field, remove the field as well.\n        const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n        if (shouldRemoveField) {\n          let argMatchCount = 0;\n          node.arguments.forEach(arg => {\n            if (argMatcher(arg)) {\n              argMatchCount += 1;\n            }\n          });\n          if (argMatchCount === 1) {\n            return null;\n          }\n        }\n      },\n    },\n\n    Argument: {\n      enter(node) {\n        // Remove all matching arguments.\n        if (argMatcher(node)) {\n          return null;\n        }\n      },\n    },\n  }));\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if ((selection.kind === 'Field' ||\n         selection.kind === 'InlineFragment') &&\n        selection.selectionSet) {\n      getAllFragmentSpreadsFromSelectionSet(\n        selection.selectionSet\n      ).forEach(frag => allFragments.push(frag));\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n","const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper<T>(val: T, seen: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","/**\n * Performs a deep equality check on two JavaScript values.\n */\nexport function isEqual(a: any, b: any): boolean {\n  // If the two values are strictly equal, we are good.\n  if (a === b) {\n    return true;\n  }\n  // Dates are equivalent if their time values are equal.\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  // If a and b are both objects, we will compare their properties. This will compare arrays as\n  // well.\n  if (\n    a != null &&\n    typeof a === 'object' &&\n    b != null &&\n    typeof b === 'object'\n  ) {\n    // Compare all of the keys in `a`. If one of the keys has a different value, or that key does\n    // not exist in `b` return false immediately.\n    for (const key in a) {\n      if (Object.prototype.hasOwnProperty.call(a, key)) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\n          return false;\n        }\n        if (!isEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n    // Look through all the keys in `b`. If `b` has a key that `a` does not, return false.\n    for (const key in b) {\n      if (\n        Object.prototype.hasOwnProperty.call(b, key) &&\n        !Object.prototype.hasOwnProperty.call(a, key)\n      ) {\n        return false;\n      }\n    }\n    // If we made it this far the objects are equal!\n    return true;\n  }\n  // Otherwise the values are not equal.\n  return false;\n}\n","import { isDevelopment, isTest } from './environment';\n\n// Taken (mostly) from https://github.com/substack/deep-freeze to avoid\n// import hassles with rollup.\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\nexport function maybeDeepFreeze(obj: any) {\n  if (isDevelopment() || isTest()) {\n    // Polyfilled Symbols potentially cause infinite / very deep recursion while deep freezing\n    // which is known to crash IE11 (https://github.com/apollographql/apollo-client/issues/3043).\n    const symbolIsPolyfilled =\n      typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n  return obj;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (isProduction()) {\n    return;\n  }\n  if (!haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    switch (type) {\n      case 'error':\n        console.error(msg);\n        break;\n      default:\n        console.warn(msg);\n    }\n  }\n}\n","/**\n * In order to make assertions easier, this function strips `symbol`'s from\n * the incoming data.\n *\n * This can be handy when running tests against `apollo-client` for example,\n * since it adds `symbol`'s to the data in the store. Jest's `toEqual`\n * function now covers `symbol`'s (https://github.com/facebook/jest/pull/3437),\n * which means all test data used in a `toEqual` comparison would also have to\n * include `symbol`'s, to pass. By stripping `symbol`'s from the cache data\n * we can compare against more simplified test data.\n */\nexport function stripSymbols<T>(data: T): T {\n  return JSON.parse(JSON.stringify(data));\n}\n"],"names":["visit"],"mappings":"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"}