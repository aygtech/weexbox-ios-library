"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loading_1 = require("apollo-codegen-core/lib/loading");
const localfs_1 = require("apollo-codegen-core/lib/localfs");
const apollo_link_1 = require("apollo-link");
const apollo_link_http_1 = require("apollo-link-http");
const graphql_1 = require("graphql");
const graphql_tag_1 = require("graphql-tag");
const https_1 = require("https");
const node_fetch_1 = require("node-fetch");
const path = require("path");
const url_1 = require("url");
const engine_1 = require("./engine");
const schema_1 = require("./operations/schema");
const introspection = graphql_tag_1.default(graphql_1.introspectionQuery);
async function fromFile(file) {
    try {
        const result = localfs_1.fs.readFileSync(file, {
            encoding: "utf-8"
        });
        const ext = path.extname(file);
        if (ext === ".json") {
            const parsed = JSON.parse(result);
            const schemaData = parsed.data
                ? parsed.data.__schema
                : parsed.__schema
                    ? parsed.__schema
                    : parsed;
            return graphql_1.buildClientSchema({ __schema: schemaData });
        }
        if (ext === ".graphql" || ext === ".graphqls" || ext === ".gql") {
            return graphql_1.buildSchema(new graphql_1.Source(result, file));
        }
        if (ext === ".ts" || ext === ".tsx" || ext === ".js" || ext === ".jsx") {
            return await graphql_1.buildSchema(loading_1.extractDocumentFromJavascript(result));
        }
        return undefined;
    }
    catch (e) {
        throw new Error(`Unable to read file ${file}. ${e.message}`);
    }
}
exports.fromFile = fromFile;
exports.fetchSchema = async ({ url, headers, skipSSLValidation }, projectFolder) => {
    if (!url)
        throw new Error("No endpoint provided when fetching schema");
    const filePath = projectFolder ? path.resolve(projectFolder, url) : url;
    if (localfs_1.fs.existsSync(filePath))
        return fromFile(filePath);
    var options = { uri: url, fetch: node_fetch_1.default };
    if (skipSSLValidation) {
        const urlObject = new url_1.URL(url);
        const host = urlObject.host;
        const port = +urlObject.port || 443;
        const agentOptions = {
            host: host,
            port: port,
            rejectUnauthorized: false
        };
        const agent = new https_1.Agent(agentOptions);
        options.fetchOptions = { agent: agent };
    }
    return apollo_link_1.toPromise(apollo_link_1.execute(apollo_link_http_1.createHttpLink(options), {
        query: introspection,
        context: { headers }
    })).then(({ data, errors }) => {
        if (errors)
            throw new Error(errors.map(({ message }) => message).join("\n"));
        return graphql_1.buildClientSchema({ __schema: data.__schema });
    });
};
async function fetchSchemaFromEngine(apiKey, customEngine) {
    const variables = {
        id: engine_1.getIdFromKey(apiKey),
        tag: "current"
    };
    const engineSchema = await apollo_link_1.toPromise(apollo_link_1.execute(engine_1.engineLink, {
        query: schema_1.SCHEMA_QUERY,
        variables,
        context: Object.assign({ headers: { ["x-api-key"]: apiKey } }, (customEngine && { uri: customEngine }))
    }));
    if (engineSchema.data && engineSchema.data.service.schema) {
        return graphql_1.buildClientSchema(engineSchema.data.service.schema);
    }
    else {
        throw new Error("Unable to get schema from Apollo Engine");
    }
}
exports.fetchSchemaFromEngine = fetchSchemaFromEngine;
//# sourceMappingURL=fetch-schema.js.map