"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
function loadConfigStep(flags, defaultEndpoint) {
    const header = Array.isArray(flags.header)
        ? flags.header
        : [flags.header];
    const task = {
        title: "Loading Apollo config",
        task: async (ctx) => {
            if (flags.config) {
                ctx.config = config_1.loadConfigFromFile(flags.config, defaultEndpoint, !flags.clientSchema);
            }
            else {
                ctx.config = config_1.findAndLoadConfig(process.cwd(), defaultEndpoint, !flags.clientSchema);
            }
            if (flags.schema || flags.endpoint) {
                ctx.config.schemas = {
                    default: {
                        schema: flags.schema,
                        endpoint: flags.endpoint && Object.assign({ url: flags.endpoint }, (header.length > 0 && {
                            headers: header
                                .filter(x => !!x)
                                .map(x => JSON.parse(x))
                                .reduce((a, b) => Object.assign(a, b), {})
                        }))
                    }
                };
            }
            if (flags.clientSchema) {
                const extendsName = ctx.config.schemas.default
                    ? "serverSchema"
                    : undefined;
                ctx.config.schemas.serverSchema = ctx.config.schemas.default;
                ctx.config.schemas.default = {
                    extends: extendsName,
                    schema: flags.clientSchema,
                    clientSide: true
                };
            }
            if (!ctx.config.queries ||
                (ctx.config.queries.length == 0 && flags.queries)) {
                ctx.config.queries = [
                    {
                        schema: "default",
                        includes: flags.queries.split("\n"),
                        excludes: []
                    }
                ];
            }
            else if (flags.queries && flags.queries != "**/*.graphql") {
                ctx.config.queries = ctx.config.queries.map((query) => {
                    return Object.assign({}, query, {
                        includes: flags.queries.split("\n")
                    });
                });
            }
            if (flags.key) {
                if (Object.keys(ctx.config.schemas).length == 1) {
                    Object.values(ctx.config.schemas)[0].engineKey =
                        flags.key;
                }
            }
            if (flags.engine) {
                ctx.config.engineEndpoint = flags.engine;
            }
            if (flags.skipSSLValidation) {
                if (Object.keys(ctx.config.schemas).length == 1) {
                    const endpointConfiguration = Object.values(ctx.config.schemas)[0].endpoint;
                    if (endpointConfiguration) {
                        endpointConfiguration.skipSSLValidation = flags.skipSSLValidation;
                    }
                }
            }
            if (ctx.config.queries.length == 0 && ctx.config.schemas.default) {
                ctx.config.queries.push({
                    schema: "default",
                    includes: ["**/*.graphql"],
                    excludes: []
                });
            }
        }
    };
    return task;
}
exports.loadConfigStep = loadConfigStep;
//# sourceMappingURL=load-config.js.map