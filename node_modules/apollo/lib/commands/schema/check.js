"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const chalk_1 = require("chalk");
const heroku_cli_util_1 = require("heroku-cli-util");
const Listr = require("listr");
const graphql_1 = require("graphql");
const apollo_link_1 = require("apollo-link");
const validateSchema_1 = require("../../operations/validateSchema");
const engine_1 = require("../../engine");
const fetch_schema_1 = require("../../fetch-schema");
const git_1 = require("../../git");
const ast_1 = require("../../printer/ast");
const engine_cli_1 = require("../../engine-cli");
const load_config_1 = require("../../load-config");
class SchemaCheck extends command_1.Command {
    async run() {
        const { flags } = this.parse(SchemaCheck);
        const tasks = new Listr([
            load_config_1.loadConfigStep(flags, true),
            {
                title: "Fetching local schema",
                task: async (ctx) => {
                    if (Object.values(ctx.config.schemas).length > 1) {
                        this.error("More than one schema found.");
                    }
                    if (Object.values(ctx.config.schemas).length == 0) {
                        this.error("No schemas found.");
                    }
                    ctx.currentSchema = Object.values(ctx.config.schemas)[0];
                    if (!ctx.currentSchema.engineKey) {
                        this.error("No API key was specified. Set an Apollo Engine API key using the `--key` flag or the `ENGINE_API_KEY` environment variable.");
                    }
                    ctx.schema = await fetch_schema_1.fetchSchema(ctx.currentSchema.endpoint);
                }
            },
            {
                title: "Checking schema for changes",
                task: async (ctx) => {
                    const gitContext = await git_1.gitInfo();
                    const variables = {
                        id: engine_1.getIdFromKey(ctx.currentSchema.engineKey),
                        schema: (await graphql_1.execute(ctx.schema, graphql_1.parse(graphql_1.introspectionQuery))).data
                            .__schema,
                        tag: "current",
                        gitContext
                    };
                    ctx.changes = await apollo_link_1.toPromise(apollo_link_1.execute(engine_1.engineLink, {
                        query: validateSchema_1.VALIDATE_SCHEMA,
                        variables,
                        context: Object.assign({ headers: { ["x-api-key"]: ctx.currentSchema.engineKey } }, (ctx.config.engineEndpoint && {
                            uri: ctx.config.engineEndpoint
                        }))
                    }))
                        .then(({ data, errors }) => {
                        if (errors)
                            throw new Error(errors.map(({ message }) => message).join("\n"));
                        if (!data.service)
                            throw new Error(`No schema found for ${variables.id}`);
                        return data.service.schema.checkSchema.changes;
                    })
                        .catch(e => {
                        if (e.result && e.result.errors) {
                            this.error(e.result.errors
                                .map(({ message }) => message)
                                .join("\n"));
                        }
                        else {
                            this.error(e.message);
                        }
                    });
                }
            }
        ]);
        return tasks.run().then(async ({ changes }) => {
            const failures = changes.filter(({ type }) => type === ast_1.ChangeType.FAILURE);
            const exit = failures.length > 0 ? 1 : 0;
            if (flags.json) {
                await heroku_cli_util_1.styledJSON({ changes });
                this.exit(exit);
            }
            if (changes.length === 0) {
                return this.log("\nNo changes present between schemas\n");
            }
            this.log("\n");
            heroku_cli_util_1.table(changes.map(exports.format), {
                columns: [
                    { key: "type", label: "Change" },
                    { key: "code", label: "Code" },
                    { key: "description", label: "Description" }
                ]
            });
            this.log("\n");
            this.exit(exit);
        });
    }
}
SchemaCheck.description = "Check a schema against the version registered in Apollo Engine.";
SchemaCheck.flags = Object.assign({ help: command_1.flags.help({
        char: "h",
        description: "Show command help"
    }), config: command_1.flags.string({
        description: "Path to your Apollo config file"
    }) }, engine_cli_1.engineFlags, { header: command_1.flags.string({
        multiple: true,
        parse: header => {
            const [key, value] = header.split(":");
            return JSON.stringify({ [key.trim()]: value.trim() });
        },
        description: "Additional headers to send to server for introspectionQuery"
    }), endpoint: command_1.flags.string({
        description: "The URL of the server to fetch the schema from"
    }), json: command_1.flags.boolean({
        description: "Output result as JSON"
    }) });
exports.default = SchemaCheck;
exports.format = (change) => {
    let color = (x) => x;
    if (change.type === ast_1.ChangeType.FAILURE) {
        color = chalk_1.default.red;
    }
    if (change.type === ast_1.ChangeType.WARNING) {
        color = chalk_1.default.yellow;
    }
    return {
        type: color(change.type),
        code: color(change.code),
        description: color(change.description)
    };
};
//# sourceMappingURL=check.js.map