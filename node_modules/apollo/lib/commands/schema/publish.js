"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const heroku_cli_util_1 = require("heroku-cli-util");
const Listr = require("listr");
const apollo_link_1 = require("apollo-link");
const graphql_1 = require("graphql");
const uploadSchema_1 = require("../../operations/uploadSchema");
const engine_1 = require("../../engine");
const fetch_schema_1 = require("../../fetch-schema");
const git_1 = require("../../git");
const engine_cli_1 = require("../../engine-cli");
const load_config_1 = require("../../load-config");
class SchemaPublish extends command_1.Command {
    async run() {
        const { flags } = this.parse(SchemaPublish);
        const tag = "current";
        const tasks = new Listr([
            load_config_1.loadConfigStep(flags, true),
            {
                title: "Fetching current schema",
                task: async (ctx) => {
                    if (Object.values(ctx.config.schemas).length > 1) {
                        this.error("More than one schema found.");
                    }
                    if (Object.values(ctx.config.schemas).length == 0) {
                        this.error("No schemas found.");
                    }
                    ctx.currentSchema = Object.values(ctx.config.schemas)[0];
                    if (!ctx.currentSchema.engineKey) {
                        this.error("No API key was specified. Set an Apollo Engine API key using the `--key` flag or the `ENGINE_API_KEY` environment variable.");
                    }
                    ctx.schema = await fetch_schema_1.fetchSchema(ctx.currentSchema.endpoint).catch(this.error);
                }
            },
            {
                title: `Publishing to Apollo Engine`,
                task: async (ctx, task) => {
                    task.title = `Publishing ${engine_1.getIdFromKey(ctx.currentSchema.engineKey)} to Apollo Engine`;
                    const gitContext = await git_1.gitInfo();
                    const variables = {
                        schema: (await graphql_1.execute(ctx.schema, graphql_1.parse(graphql_1.introspectionQuery))).data
                            .__schema,
                        tag,
                        gitContext,
                        id: engine_1.getIdFromKey(ctx.currentSchema.engineKey)
                    };
                    ctx.current = await apollo_link_1.toPromise(apollo_link_1.execute(engine_1.engineLink, {
                        query: uploadSchema_1.UPLOAD_SCHEMA,
                        variables,
                        context: Object.assign({ headers: { ["x-api-key"]: ctx.currentSchema.engineKey } }, (ctx.config.engineEndpoint && {
                            uri: ctx.config.engineEndpoint
                        }))
                    }))
                        .then(async ({ data, errors }) => {
                        if (errors) {
                            console.log(errors);
                            throw new Error(errors.map(({ message }) => message).join("\n"));
                        }
                        return data.service.uploadSchema;
                    })
                        .catch(e => {
                        if (e.result && e.result.errors) {
                            this.error(e.result.errors
                                .map(({ message }) => message)
                                .join("\n"));
                        }
                        else {
                            this.error(e.message);
                        }
                    });
                }
            }
        ]);
        return tasks.run().then(({ current, currentSchema }) => {
            if (!current)
                return;
            const result = {
                service: engine_1.getIdFromKey(currentSchema.engineKey),
                hash: current.tag.schema.hash,
                tag: current.tag.tag
            };
            if (flags.json)
                return heroku_cli_util_1.styledJSON(result);
            this.log("\n");
            if (current.code === "NO_CHANGES") {
                this.log("No change in schema from previous version\n");
            }
            heroku_cli_util_1.table([result], {
                columns: [
                    {
                        key: "hash",
                        label: "id",
                        format: (hash) => hash.slice(0, 6)
                    },
                    { key: "service", label: "schema" },
                    { key: "tag" }
                ]
            });
            this.log("\n");
        });
    }
}
SchemaPublish.description = "Publish a schema to Apollo Engine";
SchemaPublish.flags = Object.assign({ help: command_1.flags.help({
        char: "h",
        description: "Show command help"
    }), config: command_1.flags.string({
        description: "Path to your Apollo config file"
    }) }, engine_cli_1.engineFlags, { header: command_1.flags.string({
        multiple: true,
        parse: header => {
            const [key, value] = header.split(":");
            return JSON.stringify({ [key.trim()]: value.trim() });
        },
        description: "Additional headers to send to server for introspectionQuery"
    }), endpoint: command_1.flags.string({
        description: "The URL of the server to fetch the schema from"
    }), json: command_1.flags.boolean({
        description: "Output successful publish result as JSON"
    }) });
exports.default = SchemaPublish;
//# sourceMappingURL=publish.js.map