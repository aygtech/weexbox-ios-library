"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("apollo-codegen-core/lib/polyfills");
const command_1 = require("@oclif/command");
const Listr = require("listr");
const path = require("path");
const tty = require("tty");
const generate_1 = require("../../generate");
const engine_cli_1 = require("../../engine-cli");
const gaze_1 = require("gaze");
const config_1 = require("../../config");
const load_config_1 = require("../../load-config");
const waitForKey = async () => {
    console.log("Press any key to stop.");
    process.stdin.setRawMode(true);
    return new Promise(resolve => process.stdin.once("data", () => {
        process.stdin.unref();
        process.stdin.setRawMode(false);
        resolve();
    }));
};
class Generate extends command_1.Command {
    async run() {
        const { flags, args } = this.parse(Generate);
        let inferredTarget = "";
        if (flags.target) {
            if ([
                "json",
                "swift",
                "typescript",
                "flow",
                "scala",
                "typescript-legacy",
                "flow-legacy"
            ].includes(flags.target)) {
                inferredTarget = flags.target;
            }
            else {
                this.error(`Unsupported target: ${flags.target}`);
            }
        }
        else if (args.output) {
            switch (args.output.split(".").reverse()[0]) {
                case "json":
                    inferredTarget = "json";
                    break;
                case "swift":
                    inferredTarget = "swift";
                    break;
                case "ts" || "tsx":
                    inferredTarget = "typescript";
                    break;
                case "js" || "jsx":
                    inferredTarget = "flow";
                    break;
                case "scala":
                    inferredTarget = "scala";
                    break;
                default:
                    this.error("Could not infer target from output file type, please use --target");
                    return;
            }
        }
        if (!args.output &&
            inferredTarget != "typescript" &&
            inferredTarget != "flow") {
            this.error("The output path must be specified in the arguments for Swift and Scala");
            return;
        }
        if (!flags.outputFlat &&
            (inferredTarget === "typescript" || inferredTarget === "flow") &&
            (args.output &&
                (path.isAbsolute(args.output) ||
                    args.output.split(path.sep).length > 1))) {
            this.error('For TypeScript and Flow generators, "output" must be empty or a single directory name, unless the "outputFlat" flag is set.');
            return;
        }
        const tasks = new Listr([
            load_config_1.loadConfigStep(flags, false),
            {
                title: "Resolving GraphQL document sets and dependencies",
                task: async (ctx, task) => {
                    ctx.documentSets = await config_1.resolveDocumentSets(ctx.config, true);
                    task.title = `Scanning for GraphQL queries (${ctx.documentSets
                        .map(s => s.documentPaths.length)
                        .reduce((a, b) => a + b, 0)} found)`;
                }
            },
            {
                title: "Generating query files",
                task: async (ctx, task) => {
                    task.title = `Generating query files with '${inferredTarget}' target`;
                    if (ctx.documentSets.length == 0) {
                        this.error("No document sets found to generate code for.");
                    }
                    else if (ctx.documentSets.length == 1) {
                        const set = ctx.documentSets[0];
                        const writtenFiles = generate_1.default(set.documentPaths.map(p => path.relative(ctx.config.projectFolder, p)), set.schema, typeof args.output === "string" ? args.output : "__generated__", flags.only, inferredTarget, flags.tagName, !flags.outputFlat, {
                            passthroughCustomScalars: flags.passthroughCustomScalars || !!flags.customScalarsPrefix,
                            customScalarsPrefix: flags.customScalarsPrefix || "",
                            addTypename: flags.addTypename,
                            namespace: flags.namespace,
                            operationIdsPath: flags.operationIdsPath,
                            generateOperationIds: !!flags.operationIdsPath,
                            mergeInFieldsFromFragmentSpreads: flags.mergeInFieldsFromFragmentSpreads,
                            useFlowExactObjects: flags.useFlowExactObjects,
                            useFlowReadOnlyTypes: flags.useFlowReadOnlyTypes,
                            globalTypesFile: flags.globalTypesFile
                        });
                        task.title = `Generating query files with '${inferredTarget}' target - wrote ${writtenFiles} files`;
                    }
                    else {
                        this.error("More than one document set found.");
                    }
                }
            }
        ]);
        if (flags.watch) {
            await tasks.run().catch(() => { });
            const watcher = new gaze_1.Gaze(flags.queries);
            watcher.on("all", () => {
                console.log("\nChange detected, generating types...");
                tasks.run().catch(() => { });
            });
            if (tty.isatty(process.stdin.fd)) {
                await waitForKey();
                watcher.close();
            }
            return;
        }
        else {
            return tasks.run();
        }
    }
}
Generate.description = "Generate static types for GraphQL queries. Can use the published schema in Apollo Engine or a downloaded schema.";
Generate.flags = Object.assign({ help: command_1.flags.help({
        char: "h",
        description: "Show command help"
    }), config: command_1.flags.string({
        description: "Path to your Apollo config file"
    }), queries: command_1.flags.string({
        description: "Path to your GraphQL queries, can include search tokens like **",
        default: "**/*.graphql"
    }), schema: command_1.flags.string({
        description: "Path to your GraphQL schema (.graphql, .json, .js, .ts)"
    }), clientSchema: command_1.flags.string({
        description: "Path to your client-side GraphQL schema file for `apollo-link-state` (.graphql, .json, .js, .ts)"
    }) }, engine_cli_1.engineFlags, { target: command_1.flags.string({
        description: "Type of code generator to use (swift | typescript | flow | scala), inferred from output"
    }), namespace: command_1.flags.string({
        description: "The namespace to emit generated code into."
    }), passthroughCustomScalars: command_1.flags.boolean({
        description: "Use your own types for custom scalars"
    }), customScalarsPrefix: command_1.flags.string({
        description: "Include a prefix when using provided types for custom scalars"
    }), addTypename: command_1.flags.boolean({
        description: "Automatically add __typename to your queries"
    }), operationIdsPath: command_1.flags.string({
        description: "Path to an operation id JSON map file. If specified, also stores the operation ids (hashes) as properties on operation types [currently Swift-only]"
    }), mergeInFieldsFromFragmentSpreads: command_1.flags.boolean({
        description: "Merge fragment fields onto its enclosing type"
    }), useFlowExactObjects: command_1.flags.boolean({
        description: "Use Flow exact objects for generated types [flow only]"
    }), useFlowReadOnlyTypes: command_1.flags.boolean({
        description: "Use Flow read only types for generated types [flow only]"
    }), only: command_1.flags.string({
        description: "Parse all input files, but only output generated code for the specified file [Swift only]"
    }), tagName: command_1.flags.string({
        description: "Name of the template literal tag used to identify template literals containing GraphQL queries in Javascript/Typescript code",
        default: "gql"
    }), outputFlat: command_1.flags.boolean({
        description: 'By default, TypeScript/Flow will put each generated file in a directory next to its source file using the value of the "output" as the directory name. Set "outputFlat" to put all generated files in the directory relative to the current working directory defined by "output".'
    }), globalTypesFile: command_1.flags.string({
        description: 'By default, TypeScript will put a file named "globalTypes.ts" inside the "output" directory. Set "globalTypesFile" to specify a different path.'
    }), watch: command_1.flags.boolean({
        description: "Watch the query files to auto-generate on changes."
    }) });
Generate.args = [
    {
        name: "output",
        description: `Directory to which generated files will be written.
- For TypeScript/Flow generators, this specifies a directory relative to each source file by default.
- For TypeScript/Flow generators with the "outputFlat" flag is set, and for the Swift generator, this specifies a file or directory (absolute or relative to the current working directory) to which:
  - a file will be written for each query (if "output" is a directory)
  - all generated types will be written
- For all other types, this defines a file (absolute or relative to the current working directory) to which all generated types are written.`
    }
];
exports.default = Generate;
//# sourceMappingURL=generate.js.map