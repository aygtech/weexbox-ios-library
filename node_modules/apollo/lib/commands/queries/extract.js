"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("apollo-codegen-core/lib/polyfills");
const command_1 = require("@oclif/command");
const Listr = require("listr");
const crypto = require("crypto");
const fs = require("fs");
const apollo_engine_reporting_1 = require("apollo-engine-reporting");
const loading_1 = require("apollo-codegen-core/lib/loading");
const engine_cli_1 = require("../../engine-cli");
const config_1 = require("../../config");
const load_config_1 = require("../../load-config");
class ExtractQueries extends command_1.Command {
    async run() {
        const { flags, args } = this.parse(ExtractQueries);
        const tasks = new Listr([
            load_config_1.loadConfigStep(flags, false),
            {
                title: "Resolving GraphQL document sets",
                task: async (ctx) => {
                    ctx.documentSets = await config_1.resolveDocumentSets(ctx.config, false);
                }
            },
            {
                title: "Scanning for GraphQL queries",
                task: async (ctx, task) => {
                    ctx.queryDocuments = loading_1.loadQueryDocuments(ctx.documentSets[0].documentPaths, flags.tagName);
                    task.title = `Scanning for GraphQL queries (${ctx.queryDocuments.length} found)`;
                }
            },
            {
                title: "Isolating operations and fragments",
                task: async (ctx) => {
                    const { fragments, operations } = loading_1.extractOperationsAndFragments(ctx.queryDocuments, this.error.bind(this));
                    ctx.fragments = fragments;
                    ctx.operations = operations;
                }
            },
            {
                title: "Combining operations and fragments",
                task: async (ctx) => {
                    ctx.fullOperations = loading_1.combineOperationsAndFragments(ctx.operations, ctx.fragments, this.error.bind(this));
                }
            },
            {
                title: "Normalizing Operations",
                task: async (ctx) => {
                    ctx.normalizedOperations = ctx.fullOperations.map(operation => apollo_engine_reporting_1.printWithReducedWhitespace(apollo_engine_reporting_1.sortAST(apollo_engine_reporting_1.hideLiterals(operation))));
                }
            },
            {
                title: "Generating hashes",
                task: async (ctx) => {
                    ctx.mapping = {};
                    ctx.normalizedOperations.forEach(operation => {
                        ctx.mapping[crypto
                            .createHash("sha512")
                            .update(operation)
                            .digest("base64")] = operation;
                    });
                }
            },
            {
                title: "Outputing extracted queries",
                task: async (ctx, task) => {
                    const filename = args.output;
                    task.title = "Outputing extracted queries to " + filename;
                    fs.writeFileSync(filename, JSON.stringify(ctx.mapping));
                }
            }
        ]);
        return tasks.run();
    }
}
ExtractQueries.description = "Extracts queries";
ExtractQueries.flags = Object.assign({ help: command_1.flags.help({
        char: "h",
        description: "Show command help"
    }), config: command_1.flags.string({
        description: "Path to your Apollo config file"
    }), queries: command_1.flags.string({
        description: "Path to your GraphQL queries, can include search tokens like **"
    }) }, engine_cli_1.engineFlags, { tagName: command_1.flags.string({
        description: "Name of the template literal tag used to identify template literals containing GraphQL queries in Javascript/Typescript code",
        default: "gql"
    }) });
ExtractQueries.args = [
    {
        name: "output",
        description: "Path to write the extracted queries to",
        required: true,
        default: "manifest.json"
    }
];
exports.default = ExtractQueries;
//# sourceMappingURL=extract.js.map