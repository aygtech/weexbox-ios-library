"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("apollo-codegen-core/lib/polyfills");
const command_1 = require("@oclif/command");
const heroku_cli_util_1 = require("heroku-cli-util");
const Listr = require("listr");
const apollo_link_1 = require("apollo-link");
const graphql_1 = require("graphql");
const loading_1 = require("apollo-codegen-core/lib/loading");
const engine_cli_1 = require("../../engine-cli");
const engine_1 = require("../../engine");
const git_1 = require("../../git");
const validateOperations_1 = require("../../operations/validateOperations");
const ast_1 = require("../../printer/ast");
const check_1 = require("../schema/check");
const config_1 = require("../../config");
const load_config_1 = require("../../load-config");
class CheckQueries extends command_1.Command {
    async run() {
        const { flags } = this.parse(CheckQueries);
        const tasks = new Listr([
            load_config_1.loadConfigStep(flags, false),
            {
                title: "Resolving GraphQL document sets",
                task: async (ctx) => {
                    ctx.documentSets = await config_1.resolveDocumentSets(ctx.config, false);
                }
            },
            {
                title: "Scanning for GraphQL queries",
                task: async (ctx, task) => {
                    ctx.queryDocuments = loading_1.loadQueryDocuments(ctx.documentSets[0].documentPaths, flags.tagName);
                    task.title = `Scanning for GraphQL queries (${ctx.queryDocuments.length} found)`;
                }
            },
            {
                title: "Isolating operations and fragments",
                task: async (ctx) => {
                    const { fragments, operations } = loading_1.extractOperationsAndFragments(ctx.queryDocuments, this.error.bind(this));
                    ctx.fragments = fragments;
                    ctx.operations = operations;
                }
            },
            {
                title: "Combining operations and fragments",
                task: async (ctx) => {
                    ctx.fullOperations = loading_1.combineOperationsAndFragments(ctx.operations, ctx.fragments, this.error.bind(this));
                }
            },
            {
                title: "Printing operations",
                task: async (ctx) => {
                    ctx.operations = ctx.fullOperations.map(doc => ({
                        document: graphql_1.print(doc)
                    }));
                }
            },
            {
                title: "Checking query compatibility with schema",
                task: async (ctx) => {
                    if (!ctx.documentSets[0].engineKey) {
                        this.error("No API key was specified. Set an Apollo Engine API key using the `--key` flag or the `ENGINE_API_KEY` environment variable.");
                    }
                    const gitContext = await git_1.gitInfo();
                    const variables = {
                        id: engine_1.getIdFromKey(ctx.documentSets[0].engineKey),
                        tag: "current",
                        gitContext,
                        operations: ctx.operations
                    };
                    ctx.changes = await apollo_link_1.toPromise(apollo_link_1.execute(engine_1.engineLink, {
                        query: validateOperations_1.VALIDATE_OPERATIONS,
                        variables,
                        context: Object.assign({ headers: { ["x-api-key"]: ctx.documentSets[0].engineKey } }, (ctx.config.engineEndpoint && {
                            uri: ctx.config.engineEndpoint
                        }))
                    }))
                        .then(({ data, errors }) => {
                        if (errors)
                            throw new Error(errors.map(({ message }) => message).join("\n"));
                        if (!data.service)
                            throw new Error(`No schema found for ${variables.id}`);
                        return data.service.schema.checkOperations;
                    })
                        .catch(e => {
                        if (e.result && e.result.errors) {
                            this.error(e.result.errors
                                .map(({ message }) => message)
                                .join("\n"));
                        }
                        else {
                            this.error(e.message);
                        }
                    });
                }
            }
        ]);
        return tasks.run().then(async ({ changes }) => {
            const failures = changes.filter(({ type }) => type === ast_1.ChangeType.FAILURE);
            const exit = failures.length > 0 ? 1 : 0;
            if (flags.json) {
                await heroku_cli_util_1.styledJSON({ changes });
                this.exit(exit);
            }
            if (changes.length === 0) {
                return this.log("\nNo operations have issues with the current schema\n");
            }
            this.log("\n");
            heroku_cli_util_1.table(changes.map(check_1.format), {
                columns: [
                    { key: "type", label: "Change" },
                    { key: "code", label: "Code" },
                    { key: "description", label: "Description" }
                ]
            });
            this.log("\n");
            this.exit(exit);
        });
    }
}
CheckQueries.description = "Checks your GraphQL operations for compatibility with the server. Checks against the published schema in Apollo Engine.";
CheckQueries.flags = Object.assign({ help: command_1.flags.help({
        char: "h",
        description: "Show command help"
    }), config: command_1.flags.string({
        description: "Path to your Apollo config file"
    }), queries: command_1.flags.string({
        description: "Path to your GraphQL queries, can include search tokens like **"
    }), json: command_1.flags.boolean({
        description: "Output result as JSON"
    }) }, engine_cli_1.engineFlags, { tagName: command_1.flags.string({
        description: "Name of the template literal tag used to identify template literals containing GraphQL queries in Javascript/Typescript code",
        default: "gql"
    }) });
exports.default = CheckQueries;
//# sourceMappingURL=check.js.map